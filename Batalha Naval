#include <stdio.h>
#include <stdlib.h>

#define BOARD_SIZE 10

// Valores do tabuleiro: 0 - água; 3 - navio; 5 - área afetada por habilidade

void print_board(int board[BOARD_SIZE][BOARD_SIZE]) {
    printf("Legenda: 0=Agua  3=Navio  5=Area Habilidade\n\n");
    for (int r = 0; r < BOARD_SIZE; r++) {
        for (int c = 0; c < BOARD_SIZE; c++) {
            printf("%d ", board[r][c]);
        }
        printf("\n");
    }
    printf("\n");
}
// Inicializa um tabuleiro
void init_board(int board[BOARD_SIZE][BOARD_SIZE]) {
    // inicia todo com 0 (água)
    for (int r = 0; r < BOARD_SIZE; r++)
        for (int c = 0; c < BOARD_SIZE; c++)
            board[r][c] = 0;

    // Exemplo de navios
    // Navio 1 (horizontal)
    board[1][2] = 3;
    board[1][3] = 3;
    board[1][4] = 3;

    // Navio 2 (vertical)
    board[4][7] = 3;
    board[5][7] = 3;
    board[6][7] = 3;
    board[7][7] = 3;

    // Navio 3 (single)
    board[8][1] = 3;

    // Navio 4 (horizontal)
    board[3][0] = 3;
    board[3][1] = 3;
    board[3][2] = 3;
}

// Cria uma matriz de habilidade do tipo "cone" com dimensão n x n (n ímpar).

void build_cone(int n, int mat[n][n]) {
    int center = n / 2;
    for (int r = 0; r < n; r++) {
        for (int c = 0; c < n; c++) {
            // Condicional que determina se (r,c) entra no cone:
            // Para cada linha r, o cone cobre colunas com |c - center| <= r
            if (abs(c - center) <= r) mat[r][c] = 1;
            else mat[r][c] = 0;
        }
    }
}

// Cria uma matriz de habilidade do tipo "cruz" com dimensão n x n.

void build_cross(int n, int mat[n][n]) {
    int center = n / 2;
    for (int r = 0; r < n; r++) {
        for (int c = 0; c < n; c++) {
            if (r == center || c == center) mat[r][c] = 1;
            else mat[r][c] = 0;
        }
    }
}

// Cria uma matriz de habilidade do tipo "octaedro" vista frontal (losango/diamond).
// Aqui usamos a condição de distância de Manhattan <= radius para formar o losango.
void build_octahedron(int n, int mat[n][n]) {
    int center = n / 2;
    int radius = center; // para 5x5, radius = 2
    for (int r = 0; r < n; r++) {
        for (int c = 0; c < n; c++) {
            // Distância Manhattan ao centro
            if (abs(r - center) + abs(c - center) <= radius) mat[r][c] = 1;
            else mat[r][c] = 0;
        }
    }
}

// A função coloca uma matriz de habilidade no tabuleiro, centralizada em uma posição específica.
// Para cada célula da habilidade que contém 1, ela marca o tabuleiro com o valor indicado (como 5), sem deixar a marca sair dos limites do tabuleiro.
void overlay_skill(int board[BOARD_SIZE][BOARD_SIZE],
                   int n, int skill[n][n],
                   int origin_r, int origin_c, int marker) {
    int center = n / 2;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (skill[i][j] != 1) continue; // células da área (valor 1)

            int target_r = origin_r + (i - center);
            int target_c = origin_c + (j - center);

            // Condicional para garantir dentro dos limites do tabuleiro
            if (target_r >= 0 && target_r < BOARD_SIZE && target_c >= 0 && target_c < BOARD_SIZE) {
                // Marca com 'marker'. 
                // Observação: isto sobrescreve navios (valor 3) com 5 — se quiser preservar navios,
                board[target_r][target_c] = marker;
            }
        }
    }
}

int main() {
    int board[BOARD_SIZE][BOARD_SIZE];

    // 1) Inicializa tabuleiro e navios de exemplo
    init_board(board);

    // 2) Dimensão das matrizes de habilidade (usamos 5x5 padrão para demonstração)
    const int N = 5;
    int cone[N][N];
    int cross[N][N];
    int octa[N][N];

    // 3) Construção dinâmica das matrizes de habilidade (usando loops e condicionais)
    build_cone(N, cone);
    build_cross(N, cross);
    build_octahedron(N, octa);

    // 4) Define pontos de origem (linha, coluna) para cada habilidade no tabuleiro.
    // Estas posições são fixas no código.
    // Coordenadas: 0..9
    int origin_cone_r = 2, origin_cone_c = 4;    // cone centrado em (2,4)
    int origin_cross_r = 5, origin_cross_c = 2;  // cruz centrada em (5,2)
    int origin_octa_r = 6, origin_octa_c = 6;    // octaedro centrado em (6,6)

    // 5) Sobrepõe as habilidades no tabuleiro
    overlay_skill(board, N, cone, origin_cone_r, origin_cone_c, 5);
    overlay_skill(board, N, cross, origin_cross_r, origin_cross_c, 5);
    overlay_skill(board, N, octa, origin_octa_r, origin_octa_c, 5);

    // 6) Exibe o resultado final.
    printf("Tabuleiro com areas de efeito (valores numericos):\n\n");
    print_board(board);

    // Para visualização das matrizes de habilidade independentemente (opcional),
    // Impressão de matrizes construídas:
    printf("Matriz Cone (1 = area):\n");
    for (int r = 0; r < N; r++) {
        for (int c = 0; c < N; c++)
            printf("%d ", cone[r][c]);
        printf("\n");
    }
    printf("\n");

    printf("Matriz Cruz (1 = area):\n");
    for (int r = 0; r < N; r++) {
        for (int c = 0; c < N; c++)
            printf("%d ", cross[r][c]);
        printf("\n");
    }
    printf("\n");

    printf("Matriz Octaedro (1 = area):\n");
    for (int r = 0; r < N; r++) {
        for (int c = 0; c < N; c++)
            printf("%d ", octa[r][c]);
        printf("\n");
    }
    printf("\n");

    return 0;
}
